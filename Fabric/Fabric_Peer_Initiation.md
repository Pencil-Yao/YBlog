# first-network例程分析
## 一. byfn.sh
### 1.配置参数：
``` shell
# Obtain the OS and Architecture string that will be used to select the correct
# native binaries for your platform
OS_ARCH=$(echo "$(uname -s|tr '[:upper:]' '[:lower:]'|sed 's/mingw64_nt.*/windows/')-$(uname -m | sed 's/x86_64/amd64/g')" | awk '{print tolower($0)}')
# timeout duration - the duration the CLI should wait for a response from
# another container before giving up
CLI_TIMEOUT=10
#default for delay
CLI_DELAY=1
# channel name defaults to "mychannel"
CHANNEL_NAME="mychannel"
# use this as the default docker-compose yaml definition
COMPOSE_FILE=docker-compose-cli.yaml
#
COMPOSE_FILE_COUCH=docker-compose-couch.yaml
```
主要指定channelName（后面亦作为chainID）和docker-compose文件
### 2.生成证书和私匙
``` shell
  elif [ "${MODE}" == "generate" ]; then ## Generate Artifacts
  generateCerts
  replacePrivateKey
  generateChannelArtifacts
```
generateCerts为排序节点与各个账本节点的组织生成单独的证书（cacerts），私匙（keystore），公匙（signcerts）
``` shell
# Cryptogen consumes a file - ``crypto-config.yaml`` - that contains the network
# topology and allows us to generate a library of certificates for both the
# Organizations and the components that belong to those Organizations.  Each
# Organization is provisioned a unique root certificate (``ca-cert``), that binds
# specific components (peers and orderers) to that Org.  Transactions and communications
# within Fabric are signed by an entity's private key (``keystore``), and then verified
# by means of a public key (``signcerts``).  You will notice a "count" variable within
# this file.  We use this to specify the number of peers per Organization; in our
# case it's two peers per Org.  The rest of this template is extremely
# self-explanatory.
# After we run the tool, the certs will be parked in a folder titled ``crypto-config``.
function generateCerts (){
  which cryptogen
  if [ "$?" -ne 0 ]; then
    echo "cryptogen tool not found. exiting"
    exit 1
  fi
  echo
  echo "##########################################################"
  echo "##### Generate certificates using cryptogen tool #########"
  echo "##########################################################"
  if [ -d "crypto-config" ]; then
    rm -Rf crypto-config
  fi
  cryptogen generate --config=./crypto-config.yaml
  if [ "$?" -ne 0 ]; then
    echo "Failed to generate certificates..."
    exit 1
  fi
  echo
}
```
replacePrivateKey将ca中私匙替代e2e文件
``` shell
# Using docker-compose-e2e-template.yaml, replace constants with private key file names
# generated by the cryptogen tool and output a docker-compose.yaml specific to this
# configuration
function replacePrivateKey () {
  # sed on MacOSX does not support -i flag with a null extension. We will use
  # 't' for our back-up's extension and depete it at the end of the function
  ARCH=`uname -s | grep Darwin`
  if [ "$ARCH" == "Darwin" ]; then
    OPTS="-it"
  else
    OPTS="-i"
  fi

  # Copy the template to the file that will be modified to add the private key
  cp docker-compose-e2e-template.yaml docker-compose-e2e.yaml

  # The next steps will replace the template's contents with the
  # actual values of the private key file names for the two CAs.
  CURRENT_DIR=$PWD
  cd crypto-config/peerOrganizations/org1.example.com/ca/
  PRIV_KEY=$(ls *_sk)
  cd "$CURRENT_DIR"
  sed $OPTS "s/CA1_PRIVATE_KEY/${PRIV_KEY}/g" docker-compose-e2e.yaml
  cd crypto-config/peerOrganizations/org2.example.com/ca/
  PRIV_KEY=$(ls *_sk)
  cd "$CURRENT_DIR"
  sed $OPTS "s/CA2_PRIVATE_KEY/${PRIV_KEY}/g" docker-compose-e2e.yaml
  # If MacOSX, remove the temporary backup of the docker-compose file
  if [ "$ARCH" == "Darwin" ]; then
    rm docker-compose-e2e.yamlt
  fi
}
```
generateChannelArtifacts 产生创世区块（genesis.block），该区块文件会拷入排序节点容器中，并将其位置定义给ORDERER_GENERAL_GENESISFILE，创建通道的配置交易文件（channel.tx）后续用于创建通道，创建锚节点更新交易文件（Org1MSPanchors.tx，Org2MSPanchors.tx）后续用于配置锚节点及通道配置的更新
``` shell
# The `configtxgen tool is used to create four artifacts: orderer **bootstrap
# block**, fabric **channel configuration transaction**, and two **anchor
# peer transactions** - one for each Peer Org.
#
# The orderer block is the genesis block for the ordering service, and the
# channel transaction file is broadcast to the orderer at channel creation
# time.  The anchor peer transactions, as the name might suggest, specify each
# Org's anchor peer on this channel.
#
# Configtxgen consumes a file - ``configtx.yaml`` - that contains the definitions
# for the sample network. There are three members - one Orderer Org (``OrdererOrg``)
# and two Peer Orgs (``Org1`` & ``Org2``) each managing and maintaining two peer nodes.
# This file also specifies a consortium - ``SampleConsortium`` - consisting of our
# two Peer Orgs.  Pay specific attention to the "Profiles" section at the top of
# this file.  You will notice that we have two unique headers. One for the orderer genesis
# block - ``TwoOrgsOrdererGenesis`` - and one for our channel - ``TwoOrgsChannel``.
# These headers are important, as we will pass them in as arguments when we create
# our artifacts.  This file also contains two additional specifications that are worth
# noting.  Firstly, we specify the anchor peers for each Peer Org
# (``peer0.org1.example.com`` & ``peer0.org2.example.com``).  Secondly, we point to
# the location of the MSP directory for each member, in turn allowing us to store the
# root certificates for each Org in the orderer genesis block.  This is a critical
# concept. Now any network entity communicating with the ordering service can have
# its digital signature verified.
#
# This function will generate the crypto material and our four configuration
# artifacts, and subsequently output these files into the ``channel-artifacts``
# folder.
#
# If you receive the following warning, it can be safely ignored:
#
# [bccsp] GetDefault -> WARN 001 Before using BCCSP, please call InitFactories(). Falling back to bootBCCSP.
#
# You can ignore the logs regarding intermediate certs, we are not using them in
# this crypto implementation.

# Generate orderer genesis block, channel configuration transaction and
# anchor peer update transactions
function generateChannelArtifacts() {
  which configtxgen
  if [ "$?" -ne 0 ]; then
    echo "configtxgen tool not found. exiting"
    exit 1
  fi

  echo "##########################################################"
  echo "#########  Generating Orderer Genesis block ##############"
  echo "##########################################################"
  # Note: For some unknown reason (at least for now) the block file can't be
  # named orderer.genesis.block or the orderer will fail to launch!
  configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
  if [ "$?" -ne 0 ]; then
    echo "Failed to generate orderer genesis block..."
    exit 1
  fi
  echo
  echo "#################################################################"
  echo "### Generating channel configuration transaction 'channel.tx' ###"
  echo "#################################################################"
  configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
  if [ "$?" -ne 0 ]; then
    echo "Failed to generate channel configuration transaction..."
    exit 1
  fi

  echo
  echo "#################################################################"
  echo "#######    Generating anchor peer update for Org1MSP   ##########"
  echo "#################################################################"
  configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
  if [ "$?" -ne 0 ]; then
    echo "Failed to generate anchor peer update for Org1MSP..."
    exit 1
  fi

  echo
  echo "#################################################################"
  echo "#######    Generating anchor peer update for Org2MSP   ##########"
  echo "#################################################################"
  configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate \
  ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
  if [ "$?" -ne 0 ]; then
    echo "Failed to generate anchor peer update for Org2MSP..."
    exit 1
  fi
  echo
}
```
### 3.fabric网络启动
docker-compose COMPOSE_FILE命令地启动fabric网络
``` shell
# Generate the needed certificates, the genesis block and start the network.
function networkUp () {
  # generate artifacts if they don't exist
  if [ ! -d "crypto-config" ]; then
    generateCerts
    replacePrivateKey
    generateChannelArtifacts
  fi
  if [ "${IF_COUCHDB}" == "couchdb" ]; then
      CHANNEL_NAME=$CHANNEL_NAME TIMEOUT=$CLI_TIMEOUT DELAY=$CLI_DELAY docker-compose -f $COMPOSE_FILE -f $COMPOSE_FILE_COUCH up -d 2>&1
  else
      CHANNEL_NAME=$CHANNEL_NAME TIMEOUT=$CLI_TIMEOUT DELAY=$CLI_DELAY docker-compose -f $COMPOSE_FILE up -d 2>&1
  fi
  if [ $? -ne 0 ]; then
    echo "ERROR !!!! Unable to start network"
    docker logs -f cli
    exit 1
  fi
  docker logs -f cli
}
```
***
## 二. docker-compose-cli.yaml
建立byfn网络
``` yaml
networks:
  byfn:
```
### 1.排序节点启动（命令orderer）
启动服务：orderer.example.com，容器名字：orderer.example.com，加入网络：byfn，关于排序节点的配置放在base/docker-compose-base.yaml
``` yaml
services:
  orderer.example.com:
    extends:
      file:   base/docker-compose-base.yaml
      service: orderer.example.com
    container_name: orderer.example.com
    networks:
      - byfn
```
排序节点配置base/docker-compose-base.yaml，排序节点镜像：hyperledger/fabric-orderer，环境变量设置（ORDERER_开头），WD work direction（/opt/gopath/src/github.com/hyperledger/fabric），容器初始命令（orderer），容器卷的物理地址（volums），端口映射（ports: 主机：容器）
``` yaml
  orderer.example.com:
    container_name: orderer.example.com
    image: hyperledger/fabric-orderer
    environment:
      - ORDERER_GENERAL_LOGLEVEL=debug
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
      # enabled TLS
      - ORDERER_GENERAL_TLS_ENABLED=true
      - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key
      - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt
      - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric
    command: orderer
    volumes:
    - ../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block
    - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp
    - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls
    ports:
      - 7050:7050
```
### 2.peer节点配置与启动
根据configtx.yaml显示first-network一共配置了4个peer节点，4个peer节点分别平均分配给两个组织Org1，Org2，peer节点设置与排序节点类似
``` yaml
  peer0.org1.example.com:
    container_name: peer0.org1.example.com
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.org1.example.com
    networks:
      - byfn
```
在扩展文件中base/docker-compose-base.yaml，peer节点配置如下：与排序节点不同的是，peer节点还需通过扩展文件peer-base.yaml进行配置，服务名称peer-base（服务名称用于查找在扩展文件中参数配置，在服务列表下的peer-base），7051和7053的端口映射
``` yaml
  peer0.org1.example.com:
    container_name: peer0.org1.example.com
    extends:
      file: peer-base.yaml
      service: peer-base
    environment:
      - CORE_PEER_ID=peer0.org1.example.com
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
    volumes:
        - /var/run/:/host/var/run/
        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp
        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls
    ports:
      - 7051:7051
      - 7053:7053
```
peer-base.yaml中peer节点配置，镜像文件hyperledger/fabric-peer，初始启动命令为peer node start
``` yaml
services:
  peer-base:
    image: hyperledger/fabric-peer
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      # the following setting starts chaincode containers on the same
      # bridge network as the peers
      # https://docs.docker.com/compose/networking/
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=${COMPOSE_PROJECT_NAME}_byfn
      #- CORE_LOGGING_LEVEL=ERROR
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_GOSSIP_USELEADERELECTION=true
      - CORE_PEER_GOSSIP_ORGLEADER=false
      - CORE_PEER_PROFILE_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    command: peer node start
```
### 3.cli容器
cli容器地址与peer0.org1.example.com:7051通信，可以使用终端tty，依赖peer0.org1，peer1.org1，peer0.org2，peer1.org2容器建立
``` yaml
  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    command: /bin/bash -c './scripts/script.sh ${CHANNEL_NAME} ${DELAY}; sleep $TIMEOUT'
    volumes:
        - /var/run/:/host/var/run/
        - ./../chaincode/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go
        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
        - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/
        - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts
    depends_on:
      - orderer.example.com
      - peer0.org1.example.com
      - peer1.org1.example.com
      - peer0.org2.example.com
      - peer1.org2.example.com
    networks:
      - byfn
```
***
## 三. peer node start
进入/peer/node/stat.go，启动peer服务
1.获取localmsp的type类型（mspType := mgmt.GetLocalMSP().GetType()）
    - 从环境变量CORE_PEER_LOCALMSPTYPE获取localmsptype，如果没有获取到设置默认msp.FABRIC对应“bccsp”
        - 过去不存在localMsp情况下根据配置的设置新建一个，过去存在话使用过去存在的
        - 如果defaultBccsp存在的话，直接返回，如果不存在话生成一个默认的

``` go
&FactoryOpts{
    ProviderName: "SW",
    SwOpts: &SwOpts{
        HashFamily: "SHA2",
        SecLevel:   256,

        Ephemeral: true,
    }
```
获取GetType()函数调用的是GetLocalMSP()返回的cachedMSP中隐形成员msp.MSP(bccsp)的方法GetType()，返回FABRIC
``` go
mspType := mgmt.GetLocalMSP().GetType()
```
2.注册ACL列表，由于传入nil值，网络会初始化一个defaultACL
3.初始化交易文件处理方法，初始化两种类型，代码如下
``` go
var configTxProcessor = newConfigTxProcessor()
var ConfigTxProcessors = customtx.Processors{
    common.HeaderType_CONFIG:               configTxProcessor,
    common.HeaderType_PEER_RESOURCE_UPDATE: configTxProcessor,
}
```
4.配置chaincode的模式（默认不进行配置）
``` go
viper.Set("chaincode.mode", chaincode.DevModeUserRunsChaincode)
```
5.配置peer端点，得到peer的host和port
``` go
peerEndpoint, err := peer.GetPeerEndpoint()
var peerHost string
peerHost, _, err = net.SplitHostPort(peerEndpoint.Address)
```
6.获取peer端点监听地址和服务器配置，创建peerserver(grpcserver)，listenAddr: 0.0.0.0:7051 serverConfig: 进配置了TLS为配置Keepalive
``` go
listenAddr := viper.GetString("peer.listenAddress")
serverConfig, err := peer.GetServerConfig()
peerServer, err := peer.CreatePeerServer(listenAddr, serverConfig)
```
func NewGRPCServerFromListener(listener net.Listener, serverConfig ServerConfig) (GRPCServer, error)函数中将TLS配置的证书传入GRPCServer中（不包含私匙）
7.创建事件处理服务器，地址0.0.0.0:7053
ehubGrpcServer, err := createEventHubServer(serverConfig)配置事件服务器各个设置（keepalive的设置，事件存储与管理相关的设置这部分设置可以在core.yaml中的peer.events中查找设置），创建不同event类型列表
``` go
switch eventType {
    case pb.EventType_BLOCK:
        gEventProcessor.eventConsumers[eventType] = &genericHandlerList{handlers: make(map[*handler]bool)}
    case pb.EventType_FILTEREDBLOCK:
        gEventProcessor.eventConsumers[eventType] = &genericHandlerList{handlers: make(map[*handler]bool)}
    case pb.EventType_CHAINCODE:
        gEventProcessor.eventConsumers[eventType] = &chaincodeHandlerList{handlers: make(map[string]map[string]map[*handler]bool)}
    case pb.EventType_REJECTION:
        gEventProcessor.eventConsumers[eventType] = &genericHandlerList{handlers: make(map[*handler]bool)}
}
```
开启event处理器event.go/func initializeEvents(config *EventsServerConfig);
``` go
go gEventProcessor.start()
```
最后将event的grpcserver注册 start.go/func createEventHubServer(serverConfig comm.ServerConfig) (comm.GRPCServer, error);
``` go
pb.RegisterEventsServer(grpcServer.Server(), ehServer)
```
8.创建消息获取处理器并注册
``` go
abServer := peer.NewDeliverEventsServer(mutualTLS, policyCheckerProvider, &peer.DeliverSupportManager{})
pb.RegisterDeliverServer(peerServer.Server(), abServer)
```
9.允许chaincode info缓存
``` go
// enable the cache of chaincode info
ccprovider.EnableCCInfoCache()
```
10.创建chaincode监听服务，地址为peer0.org1.example.com:7052，与evnet监听服务器，delieverevent监听服务器类似均为grpcserver
``` go
// Create a self-signed CA for chaincode service
ca, err := accesscontrol.NewCA()
ccSrv, ccEndpoint, err := createChaincodeServer(ca, peerHost)
registerChaincodeSupport(ccSrv, ccEndpoint, ca)
go ccSrv.Start()
logger.Debugf("Running peer")
```
11.注册adminserver
``` go
// Register the Admin server
pb.RegisterAdminServer(peerServer.Server(), core.NewAdminServer())
```
12.注册背书节点
创建默认的背书服务serverEndorser
``` go
serverEndorser := endorser.NewEndorserServer(privDataDist, &endorser.SupportImpl{})
libConf := library.Config{}
if err = viperutil.EnhancedExactUnmarshalKey("peer.handlers", &libConf); err != nil {
    return errors.WithMessage(err, "could not load YAML config")
}
authFilters := library.InitRegistry(libConf).Lookup(library.Auth).([]authHandler.Filter)
auth := authHandler.ChainFilters(serverEndorser, authFilters...)
// Register the Endorser server
pb.RegisterEndorserServer(peerServer.Server(), auth)
```
13.初始化、启动GossipService
获取gossip的启动地址作为通道内节点通信地址
``` go
// Initialize gossip component
bootstrap := viper.GetStringSlice("peer.gossip.bootstrap")
```
Initialize gossip with endpoint peer0.org1.example.com:7051 and bootstrap set [127.0.0.1:7051]
``` go
serializedIdentity, err := mgmt.GetLocalSigningIdentityOrPanic().Serialize()
if err != nil {
    logger.Panicf("Failed serializing self identity: %v", err)
}

messageCryptoService := peergossip.NewMCS(
    peer.NewChannelPolicyManagerGetter(),
    localmsp.NewSigner(),
    mgmt.NewDeserializersManager())
secAdv := peergossip.NewSecurityAdvisor(mgmt.NewDeserializersManager())

// callback function for secure dial options for gossip service
secureDialOpts := func() []grpc.DialOption {
    var dialOpts []grpc.DialOption
    // set max send/recv msg sizes
    dialOpts = append(dialOpts, grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(comm.MaxRecvMsgSize()),
        grpc.MaxCallSendMsgSize(comm.MaxSendMsgSize())))
    // set the keepalive options
    kaOpts := comm.DefaultKeepaliveOptions()
    if viper.IsSet("peer.keepalive.client.interval") {
        kaOpts.ClientInterval = viper.GetDuration("peer.keepalive.client.interval")
    }
    if viper.IsSet("peer.keepalive.client.timeout") {
        kaOpts.ClientTimeout = viper.GetDuration("peer.keepalive.client.timeout")
    }
    dialOpts = append(dialOpts, comm.ClientKeepaliveOptions(kaOpts)...)

    if comm.TLSEnabled() {
        dialOpts = append(dialOpts, grpc.WithTransportCredentials(comm.GetCredentialSupport().GetPeerCredentials()))
    } else {
        dialOpts = append(dialOpts, grpc.WithInsecure())
    }
    return dialOpts
}

var certs *common2.TLSCertificates
if peerServer.TLSEnabled() {
    serverCert := peerServer.ServerCertificate()
    clientCert, err := peer.GetClientCertificate()
    if err != nil {
        return errors.Wrap(err, "failed obtaining client certificates")
    }
    certs = &common2.TLSCertificates{}
    certs.TLSServerCert.Store(&serverCert)
    certs.TLSClientCert.Store(&clientCert)
}

err = service.InitGossipService(serializedIdentity, peerEndpoint.Address, peerServer.Server(), certs,
    messageCryptoService, secAdv, secureDialOpts, bootstrap...)
if err != nil {
    return err
}
defer service.GetGossipService().Stop()
```
14.初始化系统链码
``` go
//initialize system chaincodes
initSysCCs()
```
15.